#!/usr/bin/env node

var argv = process.argv.slice(1)
var fs = require("fs")
var prompt = require("prompt");
var chalk = require('chalk');
var shell = require("shelljs");
var findup = require("findup-sync");
var exec = shell.exec;
var paths = require("../paths")
var init = require("../tasks/initialise");
var test = require("../tasks/test");
var build = require("../tasks/build");
var release = require("../tasks/release");
var serve = require("../tasks/serve");
var componentPkgPath = findup("package.json")
var componentConfigPath = findup("config/index.js")
var componentPkg = componentPkgPath ? require(componentPkgPath) : {}
var componentConfig = componentConfigPath ? require(componentConfigPath) : {}

function errorAndExit(message){
    console.log(chalk.red(message.message || 'Error : ' + message));
    process.exit(1);
}
function success(message){
    if (!message || typeof message !== 'string') return
    console.log(chalk.green(message));
}

function npmGlobalPath() {
    return exec('npm config get prefix', {silent:true}).output.replace(/\s+$/g, '') + "/lib/node_modules" ;
}

var commands = {
    new: function() {
        console.log("Creating your component...");
        prompt.start();
        prompt.get([{
            description: 'Component Name',
            name: 'name'
          }, {
            description: 'Github Repository URL',
            name: 'repo'
        }], function(err, result) {
          if (!result) return;
          var component = result.name;
          var gitUrlMatch = result.repo.match(/.com\:(.*)\//);
          var author = exec('git config user.name', {silent:true}).output.replace(/\s+$/g, '');
          var moduleDir = npmGlobalPath() + '/component-helper/component-structure';
          if (!gitUrlMatch){
            errorAndExit('Github Repository URL must be a url');
          }
          if (fs.existsSync(component)){
            errorAndExit('Component `' + component + '` already exists');
          }
          if (component.indexOf(' ')>-1){
            errorAndExit('Component `' + component + '` must not contain spaces');
          }
          init.component(moduleDir, component, result.repo, author);
        });
    },
    build: function(type){
        type = type[0];
        switch (type) {
            case undefined:
                build.all(componentPkg.version).then(success, errorAndExit);
                break;
            case 'css':
                build.css().then(success, errorAndExit);
                break;
            case 'js':
                build.js().then(success, errorAndExit);
                break;
            case 'html':
                build.html(componentPkg.version).then(success, errorAndExit);
                break;
            default :
                console.log([ "Build arguments: css, js, html",
                    "Usage: `component build` or `component build css`"].join("\n"));
        }
    },
    serve: function(type){
        type = type[0];
        switch (type) {
            case undefined:
                build.all(componentPkg.version).then(function () {
                    serve(paths.site.root)
                },errorAndExit);
                break;
            case 'quick':
                serve(paths.site.root);
                break
            default :
                console.log(["Serve arguments: quick",
                    "Usage: `component test` or `component test quick`"].join("\n"));
        }
    },
    test: function(type){
        type = type[0];
        switch (type) {
            case undefined:
                build.all(componentPkg.version).then(function(){
                    return test.all().then(success, errorAndExit);
                }, errorAndExit);
                break;
            case 'once':
                test.once().then(success, errorAndExit);
                break;
            case 'tdd':
                test.tdd().then(success, errorAndExit);
                break;
            case 'coverage':
                test.coverage().then(success, errorAndExit);
                break;
            default :
                console.log([ "Test arguments: once, tdd, coverage",
                    "Usage: `component test` or `component test coverage`"].join("\n"));
        }
    },
    release: function(type){
        type = type[0];
        var typeFlag = type[1];
        switch (type) {
            case undefined:
                build.all(componentPkg.version).then(function(){
                    return test.all().then(success, errorAndExit);
                }, errorAndExit).then(function(){
                    return release.all(componentPkg.version, componentPkg.name, componentConfig.aws, typeFlag).then(success, errorAndExit);
                }, errorAndExit);
                break;
            case 'git':
                release.git(componentPkg.version).then(success, errorAndExit);
                break;
            case 'aws':
                release.aws(componentPkg.version, componentPkg.name, componentConfig.aws).then(success, errorAndExit);
                break;
            case 'gh-pages':
                release.ghPages().then(success, errorAndExit);
                break;
            default :
                console.log([ "Release arguments: git, aws, gh-pages",
                    "Usage: `component release` or `component release gh-pages`"].join("\n"));
        }
    },
    '--help': function help () {
        console.log([ "Commands: new, build, serve, test, release, --help, --version",
                  "Usage: component new"].join("\n"));
    },
    '--version': function() {
        var pkg = require("../package.json")
        var version = pkg.version;
        console.log(version);
    }
};

(function main() {
  if (!argv.length) return commands.help();
  var cwd =  argv.shift();
  var command = argv.shift();
  commands[command] && commands[command](argv);
  !commands[command] && commands.help();
})();

